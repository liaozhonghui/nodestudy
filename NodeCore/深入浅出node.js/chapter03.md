# chapter03 异步I/O

不同I/O类型的开销
cpu一级缓存
CPU二级缓存
内存
硬盘
网络

## 资源分配
对于一组互不相关的任务需要完成，解决方式：
1. 单线程串行依次执行
2. 多线程并行完成
Node的方案： 利用单线程，原理多线程死锁，状态同步等问题

## 操作系统对异步I/O的支持情况
异步I/O与非阻塞I/O
操作系统内核对于I/O只有两种方式：阻塞和非阻塞，
  内核将所有输入输出设备抽象为文件，内核在进行I/O操作的时候，通过文件描述符进行管理，而文件描述符类似于应用程序与操作系统之间的凭证.
  调用阻塞I/O时，应用程序需要等待I/O完成才返回结果.
  非阻塞I/O: 不带数据直接返回，如果要获取数据，还需要通过文件描述符再次读取
非阻塞I/O需要重复调用I/O操作来确认是否完成，这种重复调用操作是否完成的技术叫做轮询。
轮询技术：
1. read 最原始的方式，在得到最终数据之前，cpu一致消耗在等待上
2. select 是在read的基础上改进的一种方案。通过对文件描述符上的事件状态进行判断. select 轮询具有一个限制，它用1024长度的数组来存储状态，所以最多可以同时检测1024个文件描述符
3. poll 使用链表的方式来避免数组长度的限制，跟select类似
4. epoll 该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，知道事件发生将他唤醒，它是利用了事件通知，执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率最高.

### 理想中的非阻塞异步I/O
异步方法调用后立即返回 => 其他操作 => 执行回调（由I/O返回事件、信号）
现实中不存在

### 现实中的异步I/O
限定单线程
通过一个主线程进行计算处理，通过线程之间的通信将I/O数据进行传递，这样就实现了异步I/O
windows IOCP实现的异步I/O也是线程池原理
异步I/O适用范围：磁盘文件读写，硬件，套接字（被操作系统都抽象成为了文件）

## Node.js中的异步I/O
Node.js中的异步I/O实现方式：
事件循环，观察者模式
事件循环，每执行一个循环体的过程称为Tick, 每个Tick的过程是查看是否有事件待处理，如果有，就取出事件以及相关的回到函数，如果存在相关联的回调函数，就执行他们，然后进入下个循环.
每个Tick的过程中，如何判断是否有事件需要处理呢？需要观察者.
对于浏览器，事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者.
在node中，事件主要来源于网络请求，文件I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O观察者等。
事件循环是一个典型的生产者/消费者模型，异步I/O、网络请求等都是时间的生产者，这些事件都被传递到对应的观察者那里，时间循环则从观察者那里取出事件并处理。
在windows下，这个循环是基于IOCP创建，而在*nix下则是基于多线程进行创建.

请求对象: node中的异步I/O调用，从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，叫做请求对象。
执行回调：组装好请求对象，送入I/O线程池中等待执行，当线程池中的I/O操作完成之后，会将获取的结果放到req->result属性上, 然后调用完成处理函数通知IOCP, 告知当前对象操作已经完成.并将线程归还线程池.   在这个过程中，我们还利用到了事件循环的I/O观察者，在每次Tick的执行中，他会调用IOCP相关的方法来检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后把它当成事件进行处理.

总结： 事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。windows使用IOCP，而linux则由epoll实现这个过程。

## 非I/O的异步API
setTimeout(), setInterval(), setImmediate(), process.nextTick()
定时器：也是异步I/O模式，但是不需要I/O线程池的参与.
调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中.
每次Tick执行的时候，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数会立即执行.
特点： 定时器并不是精确的，
process.nextTick(), 立即执行异步任务的方法， 用于取代setTimeout(fn, 0)的方式，简单并且高效.
process.nextTick() 使用数组存储回调任务，并且一次性执行完.
setImmediate() 则是使用使用链表存储回调任务，一次只执行一个回调任务.
执行顺序：process.nextTick (idle观察者)> 定时器观察者(setTimeout, setInterval)> I/O观察者 > setImmediate()(check观察者)
 
## 事件驱动与高性能服务器
异步I/O不仅仅用在文件操作上，而且还用在网络套接字上，都是用了I/O观察者.
经典服务器模型
- 同步式 一次只能处理一个请求，其他请求都处于等待状态
- 每进程/每请求 为每个请求启动一个进程，可以处理多个请求，但是不具备拓展性
- 每线程/每请求 为每个请求启动一个线程来处理， 由于线程都占用一定的内存，当大并发请求到来的时候，内存会很快被用光，导致服务器缓慢
node用事件驱动的方式处理请求，不需要额外创建对应的线程，可以省掉创建线程和销毁线程的开销.同时操作系统在调度任务的时候线程较少，上线文切换的代价很低.
